#include <InfinityLayout.hpp>

#include <sha1.hpp>

#include <MainApplication.hpp>

extern MainApplication::Ref g_MainApplication;

static PadState pad;

static constexpr std::array<uint8_t, 16> KEY_PREFIX = {
    0x0A, 0x14, 0xFD, 0x05, 0x07, 0xFF, 0x4B, 0xCD, 0x02, 0x6B, 0xA8, 0x3F, 0x0A, 0x3B, 0x89, 0xA9};

static constexpr std::array<uint8_t, 15> KEY_POSTFIX = {
    0x28, 0x63, 0x29, 0x20, 0x44, 0x69, 0x73, 0x6E, 0x65, 0x79, 0x20, 0x32, 0x30, 0x31, 0x33};

InfinityLayout::InfinityLayout() : Layout::Layout()
{
  // Create the TextBlock instance with the text we want
  this->figureText = pu::ui::elm::TextBlock::New(300, 300, "Press X to Scan a Figure");
  this->fileText = pu::ui::elm::TextBlock::New(300, 400, "");
  this->progressBar =
      pu::ui::elm::ProgressBar::New(20, 500, pu::ui::render::ScreenWidth - 40, 50, 5);
  // Add the instance to the layout. IMPORTANT! this MUST be done for them to be used, having them
  // as members is not enough (just a simple way to keep them)
  this->Add(this->figureText);
  this->Add(this->fileText);
  this->Add(this->progressBar);

  this->SetOnInput([&](const u64 keys_down, const u64 keys_up, const u64 keys_held,
                       const pu::ui::TouchPoint touch_pos) {
    // If + is pressed, exit application
    if (keys_down & HidNpadButton_Plus)
    {
      g_MainApplication->Close();
    }
    else if (keys_down & HidNpadButton_X)
    {
      this->fileText->SetText("");
      auto rc = ProcessFigure();
      if (R_SUCCEEDED(rc))
      {
        this->progressBar->SetProgress(0);
        this->figureText->SetText("Press X to Scan a Figure");
        this->fileText->SetText("");
      }
    }
    else if (keys_down & HidNpadButton_B)
    {
      g_MainApplication->LoadLayout(g_MainApplication->GetMainLayout());
      this->progressBar->SetProgress(0);
      this->figureText->SetText("Press X to Scan a Figure");
      this->fileText->SetText("");
    }
  });
}

// Indefinitely wait for an event to be signaled
// Break when + is pressed, or if the application should quit (in this case, return value will be
// non-zero)
Result InfinityLayout::EventWaitLoop(Event* event)
{
  Result rc = 1;
  while (appletMainLoop())
  {
    rc = eventWait(event, 0);
    padUpdate(&pad);
    if (R_SUCCEEDED(rc) || (padGetButtonsDown(&pad) & HidNpadButton_Plus))
      break;
  }
  return rc;
}

std::vector<u8> InfinityLayout::CalculateKeyA(u8 nuid[7])
{
  // The key is generated by SHA1 hashing the 7 byte NUID, and taking the first 6 bytes of the hash.
  std::vector<u8> sha1Data = {KEY_PREFIX.begin(), KEY_PREFIX.end()};
  for (int i = 0; i < 7; i++)
  {
    sha1Data.push_back(nuid[i]);
  }
  sha1Data.insert(sha1Data.end(), KEY_POSTFIX.begin(), KEY_POSTFIX.end());
  SHA1 checksum;
  checksum.update(std::string(sha1Data.begin(), sha1Data.end()));
  const std::string hash = checksum.final();

  std::vector<u8> bytes;

  for (unsigned int i = 0; i < hash.length(); i += 2)
  {
    std::string byteString = hash.substr(i, 2);
    u8 byte = (u8)strtol(byteString.c_str(), NULL, 16);
    bytes.push_back(byte);
  }

  return bytes;
}

NfcMifareReadBlockParameter InfinityLayout::GenerateMifareParam(u8 block, u8 nuid[7])
{
  NfcMifareReadBlockParameter param;
  param.sector_number = block;
  NfcSectorKey key;
  key.mifare_command = NfcMifareCommand_AuthA;
  key.unknown = 1;
  auto key_bytes = CalculateKeyA(nuid);
  key.sector_key[0] = key_bytes[3];
  key.sector_key[1] = key_bytes[2];
  key.sector_key[2] = key_bytes[1];
  key.sector_key[3] = key_bytes[0];
  key.sector_key[4] = key_bytes[7];
  key.sector_key[5] = key_bytes[6];

  param.sector_key = key;
  return param;
}

Result InfinityLayout::ProcessFigure()
{
  Result rc = 0;

  // Get the handle of the first controller with NFC capabilities.
  NfcDeviceHandle handle = {0};
  if (R_SUCCEEDED(rc))
  {
    s32 device_count;
    rc = nfcMfListDevices(&device_count, &handle, 1);

    if (R_FAILED(rc))
      return rc;
  }

  if (R_SUCCEEDED(rc))
  {
    u32 npadId;
    rc = nfcMfGetNpadId(&handle, &npadId);

    if (R_FAILED(rc))
      return rc;
  }

  // Get the activation event. This is signaled when a tag is detected.
  Event activate_event = {0};
  if (R_FAILED(nfcMfAttachActivateEvent(&handle, &activate_event)))
  {
    eventClose(&activate_event);

    return rc;
  }

  // Get the deactivation event. This is signaled when a tag is removed.
  Event deactivate_event = {0};
  if (R_FAILED(nfcMfAttachDeactivateEvent(&handle, &deactivate_event)))
  {
    eventClose(&deactivate_event);
    eventClose(&activate_event);

    return rc;
  }

  NfcState state = NfcState_NonInitialized;
  if (R_SUCCEEDED(rc))
  {
    rc = nfcMfGetState(&state);

    if (R_SUCCEEDED(rc) && state == NfcState_NonInitialized)
    {
      this->figureText->SetText("Bad NFC State: " + std::to_string(state));
      g_MainApplication->CallForRender();
      rc = -1;
    }
  }

  NfcMifareDeviceState device_state = NfcMifareDeviceState_Initialized;
  if (R_SUCCEEDED(rc))
  {
    rc = nfcMfGetDeviceState(&handle, &device_state);

    if (R_SUCCEEDED(rc) && device_state > NfcMifareDeviceState_TagFound)
    {
      this->figureText->SetText("Bad NFC Device State: " + std::to_string(device_state));
      g_MainApplication->CallForRender();
      rc = -1;
    }
  }

  if (R_FAILED(rc))
  {
    eventClose(&deactivate_event);
    eventClose(&activate_event);

    return rc;
  }

  // Start the detection of tags.
  rc = nfcMfStartDetection(&handle);
  if (R_SUCCEEDED(rc))
  {
    this->figureText->SetText("Scanning for a tag...");
    g_MainApplication->CallForRender();
  }

  // Wait until a tag is detected.
  // You could also wait until nfcGetDeviceState returns NfcDeviceState_TagFound.
  if (R_SUCCEEDED(rc))
  {
    rc = EventWaitLoop(&activate_event);

    if (R_SUCCEEDED(rc))
    {
      this->figureText->SetText("A tag was detected, please do not remove it from the NFC spot.");
      g_MainApplication->CallForRender();
    }
  }

  // Retrieve the tag info data, which contains the protocol, type and uuid.
  NfcTagInfo tag_info = {0};
  if (R_SUCCEEDED(rc))
    rc = nfcMfGetTagInfo(&handle, &tag_info);

  u8 figure_data[0x14 * 0x10];
  bool read = true;

  if (R_SUCCEEDED(rc) && tag_info.tag_type == NfcTagType_Mifare)
  {
    const u8 num_blocks = 4;
    u8 nuid[7] = {tag_info.uid.uid[0], tag_info.uid.uid[1], tag_info.uid.uid[2],
                  tag_info.uid.uid[3], tag_info.uid.uid[4], tag_info.uid.uid[5],
                  tag_info.uid.uid[6]};
    for (u8 i = 0; i < 5; i++)
    {
      NfcMifareReadBlockParameter params[num_blocks];
      NfcMifareReadBlockData response[num_blocks];
      for (u8 j = 0; j < num_blocks; j++)
      {
        params[j] = GenerateMifareParam((i * 4) + j, nuid);
      }
      rc = nfcMfReadMifare(&handle, response, params, num_blocks);
      if (R_FAILED(rc))
      {
        this->figureText->SetText("Error reading sector " + std::to_string(i));
        this->fileText->SetText("Press X to try again.");
        this->progressBar->SetProgress(0);
        g_MainApplication->CallForRender();
        read = false;
        break;
      }
      else
      {
        this->progressBar->SetProgress(this->progressBar->GetProgress() + 1);
        g_MainApplication->CallForRender();
        for (u8 j = 0; j < num_blocks; j++)
        {
          //   PrintHex(response[j].data, sizeof(response[j].data));
          memcpy(&figure_data[i * 0x40 + j * 0x10], response[j].data, sizeof(response[j].data));
          if ((j + 1) % 4 == 0)
          {
            memcpy(&figure_data[i * 0x40 + j * 0x10], params[j].sector_key.sector_key,
                   sizeof(params[j].sector_key.sector_key));
          }
        }
      }
    }

    std::string fileName = "mifare/figure_data.bin";

    if (read)
    {
      FILE* file = fopen(fileName.c_str(), "wb");
      if (file)
      {
        fwrite(figure_data, 1, sizeof(figure_data), file);
        fclose(file);
        this->fileText->SetText("Figure data written to " + fileName);
        g_MainApplication->CallForRender();
      }
      else
      {
        this->fileText->SetText("Failed to open file for writing: " + fileName);
        g_MainApplication->CallForRender();
      }
    }
  }

  // Wait until the tag is removed.
  // You could also wait until nfcGetDeviceState returns NfcDeviceState_TagRemoved.
  if (R_SUCCEEDED(rc))
  {
    this->figureText->SetText("You can now remove the tag.");
    g_MainApplication->CallForRender();
    EventWaitLoop(&deactivate_event);
  }

  // Stop the detection of tags.
  nfcMfStopDetection(&handle);

  // Cleanup.
  eventClose(&deactivate_event);
  eventClose(&activate_event);

  return rc;
}
